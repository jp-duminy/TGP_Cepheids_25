    
"""
    # unfinished code
    def lomb_scargle_2(self, julian_date, magnitude):

        Employ Lomb-Scargle periodogram to locate period and then optimise this value.
        Needs error update.

        lomb_scargle = astropy.timeseries.LombScargle(julian_date, magnitude)
        frequency, power = lomb_scargle.autopower()
        best_freq = frequency[np.argmax(power)]
        false_alarm_probability = lomb_scargle.false_alarm_probability(power.max(), method='baluev') # data likely aliased

        x_fit = np.linspace(len(julian_date))
        lomb_scargle_object = astropy.timeseries.LombScargle(x_fit, magnitude)
        y_fit = lomb_scargle_object.model(x_fit, best_freq)


    def lomb_scargle_period(self):

        Employ Lomb-Scargle periodogram to locate period and then optimise this value. 
        Need update for errors.

        ncols = 3
        nrows = (len(self.time) + ncols - 1) // ncols
        fig, ax = plt.subplots(nrows, ncols)
        
        self.best_frequencies = []
        
        for i in range(len(self.time)):
            frequency, power = astropy.timeseries.LombScargle(self.julian_date[i], self.magnitude[i]).autopower()
            best_freq = frequency[np.argmax(power)]
            self.best_frequencies.append(best_freq)
            
            ax[i].plot(frequency, power)
            ax[i].set_xlabel('Frequency')
            ax[i].set_ylabel('Lomb-Scargle Power')
            ax[i].set_title(self.name[i])
            ax[i].invert_yaxis()
            ax[i].grid(True)
            
        for j in range(len(self.time), len(ax)):
            ax[j].axis('off')
        
        ax.set_title('Power Spectrum from Lomb-Scargle Periodogram')
        plt.show()

        def fit_sinusoid(self):
        
        parameters, cov = scipy.optimize.curve_fit(self.sinusoid_model, self.time, self.magnitude, 
                                                   sigma=self.magnitude_error, absolute_sigma=True)
        uncertainties = np.sqrt(np.diag(cov))
        print(f"Best-fit parameters:")
        for i in range(len(parameters)):
            print(f"{parameters[i]} \u00B1 {uncertainties[i]}")

        self.a0, self.f0, self.p0, self.o0 = parameters

"""

"""
Sinusoid construction
        for period in period_range:
            # define a rough initial guess
            a0 = (np.max(self.magnitude) - np.min(self.magnitude)) / 2 
            p0 = 0.0
            o0 = np.median(self.magnitude)
            theta = [a0, p0, o0]
            frequency = 1 / period
            print(f"Running curve fit...")
            parameters, cov = scipy.optimize.curve_fit(lambda t, a, p, o: self.sinusoid_model(t, a, p, o, frequency), 
                                                   self.time, self.magnitude, p0=theta, 
                                                   sigma=self.magnitude_error, absolute_sigma=True)
            
            print(f"Test")
            
            param_vals.append(parameters)
            uncertainties = np.sqrt(np.diag(cov))
            param_uncertainties.append(uncertainties)

            chisqu = self.sine_chi_sq(parameters, period)
            chisqu_vals.append(chisqu)


"""

"""
Emcee parameter extraction

a0, p0, o0, f0 = np.mean(self.flat_samples, axis=0)

"""

class Hierarchical_PL_Relation:
    
    def __init__(self, cepheid_finders, distances, snr_values):
        """
        Initialize with list of fitted Finder objects.
        
        Parameters:
        -----------
        cepheid_finders : list
            List of Finder objects (from run_period_fit.py) that have been fitted
        distances : array-like
            Distance to each Cepheid in parsecs
        snr_values : array-like
            Signal-to-noise ratio for each Cepheid
        """
        self.cepheid_finders = cepheid_finders
        self.n_cepheids = len(cepheid_finders)
        self.distances = np.array(distances)
        self.snr_values = np.array(snr_values)
        
        # Extract data from fitted finders
        self.extract_cepheid_data()
        
    def extract_cepheid_data(self):
        """
        Extract period posteriors, absolute magnitudes, and errors from fitted Cepheids.
        """
        self.period_posteriors = []
        self.absolute_mags = []
        self.mag_errors = []
        self.names = []
        
        for i, finder in enumerate(self.cepheid_finders):
            # Extract period posterior (4th column for sinusoid, 5th for sawtooth)
            period_post = finder.flat_samples[:, 3]  # adjust index as needed
            self.period_posteriors.append(period_post)
            
            # Get fitted magnitude (midline parameter)
            fitted_mag = finder.mc_m0  # or use np.mean(finder.magnitude)
            
            # Convert to absolute magnitude
            M_abs = Astro_Functions.apparent_to_absolute(fitted_mag, self.distances[i])
            self.absolute_mags.append(M_abs)
            
            # Compute magnitude error
            M_err = Astro_Functions.magnitude_error(self.snr_values[i])
            self.mag_errors.append(M_err)
            
            # Store name for plotting
            self.names.append(finder.name)
    
    def pl_model(self, period, a, b):
        """
        Period-Luminosity relation model.
        M = a * (log10(P) - 1) + b
        
        Parameters:
        -----------
        period : array-like
            Period in days
        a : float
            Slope
        b : float
            Intercept (absolute magnitude at P=10 days)
        """
        return a * (np.log10(period) - 1) + b
    
    def hierarchical_ln_likelihood(self, theta):
        """
        Hierarchical log-likelihood marginalizing over period uncertainties.
        
        Parameters:
        -----------
        theta : array-like
            [a, b] - slope and intercept
        """
        a, b = theta
        
        total_log_prob = 0.0
        
        for i in range(self.n_cepheids):
            # Thin period samples to reduce computation
            period_samples = self.period_posteriors[i][::50]
            
            # Compute model for each period sample
            M_model = self.pl_model(period_samples, a, b)
            M_obs = self.absolute_mags[i]
            M_err = self.mag_errors[i]
            
            # Log-likelihood for each sample
            log_likes = -0.5 * ((M_obs - M_model) / M_err)**2
            
            # Marginalize using log-sum-exp trick
            total_log_prob += scipy.special.logsumexp(log_likes) - np.log(len(period_samples))
        
        # Add normalization constant
        constant = -0.5 * np.sum(np.log(2 * np.pi * np.array(self.mag_errors)**2))
        
        return total_log_prob + constant
    
    def hierarchical_ln_prior(self, theta):
        """
        Flat priors on P-L relation parameters.
        """
        a, b = theta
        
        # Broad priors around literature values
        if -5 < a < 5 and -10 < b < 10:
            return 0.0
        return -np.inf
    
    def hierarchical_ln_prob(self, theta):
        """
        Full log-probability combining prior and likelihood.
        """
        lp = self.hierarchical_ln_prior(theta)
        if not np.isfinite(lp):
            return -np.inf
        return lp + self.hierarchical_ln_likelihood(theta)
    
    def walker_initialisation(self, nwalkers, ndim):
        """
        Initialize walkers near literature values.
        """
        # Benedict et al. (2007) values
        pos = np.array([2.43, 4.05])
        starting_position = pos + 1e-3 * np.random.randn(nwalkers, ndim)
        
        return starting_position
    
    def run_hierarchical_mcmc(self, nwalkers=32, nsteps=5000, burn_in=500):
        """
        Run hierarchical MCMC for P-L relation.
        """
        ndim = 2
        
        pos = self.walker_initialisation(nwalkers, ndim)
        sampler = mc.EnsembleSampler(nwalkers, ndim, self.hierarchical_ln_prob)
        
        # Burn-in
        print(f"Running burn-in ({burn_in} steps)...")
        pos = sampler.run_mcmc(pos, burn_in, progress=True)
        sampler.reset()
        
        # Production
        print(f"Running production ({nsteps} steps)...")
        sampler.run_mcmc(pos, nsteps, progress=True)
        
        self.sampler = sampler
        
        # Extract results
        tau = sampler.get_autocorr_time()
        thin = int(np.mean(tau) / 2)
        self.flat_samples = sampler.get_chain(thin=thin, flat=True)
        
        # Get median and uncertainties
        quantiles = [2.5, 50, 97.5]
        lower, median, upper = np.percentile(self.flat_samples, quantiles, axis=0)
        
        self.a_median, self.b_median = median
        self.a_err = (upper[0] - median[0], median[0] - lower[0])
        self.b_err = (upper[1] - median[1], median[1] - lower[1])
        
        return median, (upper - median, median - lower), tau
    
    def plot_corner(self):
        """
        Corner plot for P-L relation parameters.
        """
        labels = ["Slope (a)", "Intercept (b)"]
        fig = corner.corner(
            self.flat_samples, 
            labels=labels, 
            show_titles=True,
            quantiles=[0.025, 0.5, 0.975],
            title_fmt=".3f"
        )
        plt.show()
    
    def plot_pl_relation(self):
        """
        Plot P-L relation with data and fitted model.
        """
        fig, ax = plt.subplots(figsize=(8, 6))
        
        # Plot individual Cepheids
        median_periods = [np.median(post) for post in self.period_posteriors]
        ax.errorbar(np.log10(median_periods), self.absolute_mags, 
                   yerr=self.mag_errors, fmt='o', color='black', 
                   capsize=5, label='Cepheids')
        
        # Plot fitted relation
        period_range = np.logspace(np.log10(min(median_periods))-0.1, 
                                   np.log10(max(median_periods))+0.1, 100)
        M_fit = self.pl_model(period_range, self.a_median, self.b_median)
        
        ax.plot(np.log10(period_range), M_fit, 'r-', 
               label=f'Fit: M = {self.a_median:.2f}(log P - 1) + {self.b_median:.2f}')
        
        ax.set_xlabel('log₁₀(Period [days])')
        ax.set_ylabel('Absolute Magnitude')
        ax.invert_yaxis()
        ax.legend()
        ax.set_title('Period-Luminosity Relation')
        ax.grid(True, alpha=0.3)
        
        plt.show()
    
    def parameter_time_series(self):
        """
        Plot parameter evolution during MCMC.
        """
        fig, axes = plt.subplots(2, figsize=(10, 7), sharex=True)
        samples = self.sampler.get_chain()
        labels = ["Slope (a)", "Intercept (b)"]
        
        for i in range(2):
            ax = axes[i]
            ax.plot(samples[:, :, i], "k", alpha=0.3)
            ax.set_xlim(0, len(samples))
            ax.set_ylabel(labels[i])
            ax.yaxis.set_label_coords(-0.1, 0.5)
        
        axes[-1].set_xlabel("Step Number")
        plt.show()
    
    def print_results(self):
        """
        Print fitted P-L relation parameters.
        """
        print(f"\n{'='*50}")
        print(f"Hierarchical Period-Luminosity Relation Results")
        print(f"{'='*50}")
        print(f"Number of Cepheids: {self.n_cepheids}")
        print(f"\nFitted Parameters:")
        print(f"  Slope (a):     {self.a_median:.3f} +{self.a_err[0]:.3f} -{self.a_err[1]:.3f}")
        print(f"  Intercept (b): {self.b_median:.3f} +{self.b_err[0]:.3f} -{self.b_err[1]:.3f}")
        print(f"\nP-L Relation: M = {self.a_median:.3f}(log₁₀P - 1) + {self.b_median:.3f}")
        print(f"{'='*50}\n")